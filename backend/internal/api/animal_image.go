package api

import (
	"context"
	"fmt"
	"net/http"
	"sort"
	"strconv"
	"strings"
	"time"

	"github.com/ericogr/quimera-cards/internal/constants"
	"github.com/ericogr/quimera-cards/internal/dedupe"
	"github.com/ericogr/quimera-cards/internal/game"
	"github.com/ericogr/quimera-cards/internal/imageutil"
	"github.com/ericogr/quimera-cards/internal/logging"
	"github.com/ericogr/quimera-cards/internal/openaiclient"
	"github.com/gin-gonic/gin"
)

// GenerateAnimalImage returns a PNG image (256x256) generated by OpenAI
// based on one to three animal IDs provided in the `ids` query parameter
// (comma-separated). If more than one id is provided, the prompt will ask
// the model to merge the animals into a single chimeric superhero cartoon.
func (h *GameHandler) GenerateAnimalImage(c *gin.Context) {
	idsParam := c.Query("ids")
	if idsParam == "" {
		c.JSON(http.StatusBadRequest, gin.H{constants.JSONKeyError: constants.ErrIDsParamRequired})
		return
	}
	parts := strings.Split(idsParam, ",")
	if len(parts) < 1 || len(parts) > 3 {
		c.JSON(http.StatusBadRequest, gin.H{constants.JSONKeyError: constants.ErrIDsCountRange})
		return
	}
	ids := make([]uint, 0, len(parts))
	for _, p := range parts {
		p = strings.TrimSpace(p)
		n, err := strconv.Atoi(p)
		if err != nil || n <= 0 {
			c.JSON(http.StatusBadRequest, gin.H{constants.JSONKeyError: fmt.Sprintf(constants.ErrInvalidIDFmt, p)})
			return
		}
		ids = append(ids, uint(n))
	}

	animals, err := h.repo.GetAnimalsByIDs(ids)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{constants.JSONKeyError: constants.ErrFailedFetchAnimals})
		return
	}
	// Validate that all requested IDs were found
	found := map[uint]game.Animal{}
	for _, a := range animals {
		found[a.ID] = a
	}
	missing := []string{}
	for _, id := range ids {
		if _, ok := found[id]; !ok {
			missing = append(missing, strconv.Itoa(int(id)))
		}
	}
	if len(missing) > 0 {
		c.JSON(http.StatusBadRequest, gin.H{constants.JSONKeyError: fmt.Sprintf(constants.ErrAnimalsNotFoundFmt, strings.Join(missing, ", "))})
		return
	}

	// Preserve order from requested ids when building names
	names := make([]string, 0, len(ids))
	for _, id := range ids {
		names = append(names, found[id].Name)
	}

	// If a single animal is requested, prefer the stored image in DB.
	if len(ids) == 1 {
		a := found[ids[0]]
		if len(a.ImagePNG) > 0 {
			c.Header(constants.HeaderContentType, constants.ContentTypePNG)
			c.Header(constants.CacheControlHeader, constants.CacheControlNoCache)
			c.Writer.WriteHeader(http.StatusOK)
			if _, _ = c.Writer.Write(a.ImagePNG); true {
			}
			return
		}
		// Not stored: generate, resize and persist
		logging.Info("animal image missing in DB; generating (or joining existing)", logging.Fields{"animal_id": a.ID, "name": a.Name})
		key := fmt.Sprintf("animal:%d", a.ID)
		ch := dedupe.ImageGroup.DoChan(key, func() (interface{}, error) {
			if a2, err := h.repo.GetAnimalByName(a.Name); err == nil && a2 != nil && len(a2.ImagePNG) > 0 {
				return a2.ImagePNG, nil
			}
			ctx, cancel := context.WithTimeout(context.Background(), 90*time.Second)
			defer cancel()
			imgBytes, err := openaiclient.GenerateImageFromNames(ctx, names)
			if err != nil {
				return nil, err
			}
			outBytes, err := imageutil.ResizePNGBytes(imgBytes, 256, 256)
			if err != nil {
				return nil, err
			}
			if err := h.repo.SaveAnimalImage(a.ID, outBytes); err != nil {
				logging.Error("failed to save generated animal image", err, logging.Fields{"animal_id": a.ID})
			}
			return outBytes, nil
		})

		select {
		case r := <-ch:
			if r.Err != nil {
				c.JSON(http.StatusInternalServerError, gin.H{constants.JSONKeyError: constants.ErrOpenAIImageGenerationFailed, constants.JSONKeyDetails: r.Err.Error()})
				return
			}
			outBytes, ok := r.Val.([]byte)
			if !ok {
				c.JSON(http.StatusInternalServerError, gin.H{constants.JSONKeyError: constants.ErrOpenAIImageGenerationFailed, constants.JSONKeyDetails: "invalid image result"})
				return
			}
			c.Header(constants.HeaderContentType, constants.ContentTypePNG)
			c.Header(constants.CacheControlHeader, constants.CacheControlNoCache)
			c.Writer.WriteHeader(http.StatusOK)
			if _, _ = c.Writer.Write(outBytes); true {
			}
			return
		case <-time.After(90 * time.Second):
			c.JSON(http.StatusInternalServerError, gin.H{constants.JSONKeyError: constants.ErrOpenAIImageGenerationFailed, constants.JSONKeyDetails: "image generation timed out"})
			return
		}
	}

	// For multi-animal requests (hybrids), deduplicate by a canonical sorted
	// list of ids so concurrent requests for the same hybrid only trigger a
	// single OpenAI call.
	idsSorted := make([]int, 0, len(ids))
	for _, v := range ids {
		idsSorted = append(idsSorted, int(v))
	}
	sort.Ints(idsSorted)
	partsKey := make([]string, 0, len(idsSorted))
	for _, v := range idsSorted {
		partsKey = append(partsKey, strconv.Itoa(v))
	}
	key := fmt.Sprintf("hybrid:%s", strings.Join(partsKey, ","))

	ch := dedupe.ImageGroup.DoChan(key, func() (interface{}, error) {
		ctx, cancel := context.WithTimeout(context.Background(), 90*time.Second)
		defer cancel()
		imgBytes, err := openaiclient.GenerateImageFromNames(ctx, names)
		if err != nil {
			return nil, err
		}
		outBytes, err := imageutil.ResizePNGBytes(imgBytes, 256, 256)
		if err != nil {
			return nil, err
		}
		return outBytes, nil
	})

	select {
	case r := <-ch:
		if r.Err != nil {
			c.JSON(http.StatusInternalServerError, gin.H{constants.JSONKeyError: constants.ErrOpenAIImageGenerationFailed, constants.JSONKeyDetails: r.Err.Error()})
			return
		}
		outBytes, ok := r.Val.([]byte)
		if !ok {
			c.JSON(http.StatusInternalServerError, gin.H{constants.JSONKeyError: constants.ErrOpenAIImageGenerationFailed, constants.JSONKeyDetails: "invalid image result"})
			return
		}
		c.Header(constants.HeaderContentType, constants.ContentTypePNG)
		c.Header(constants.CacheControlHeader, constants.CacheControlNoCache)
		c.Writer.WriteHeader(http.StatusOK)
		if _, _ = c.Writer.Write(outBytes); true {
		}
		return
	case <-time.After(90 * time.Second):
		c.JSON(http.StatusInternalServerError, gin.H{constants.JSONKeyError: constants.ErrOpenAIImageGenerationFailed, constants.JSONKeyDetails: "image generation timed out"})
		return
	}
}
